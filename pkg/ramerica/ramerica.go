package ramerica

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"

	"net/url"

	"github.com/PuerkitoBio/goquery"
	"github.com/pkg/errors"
	"github.com/savaki/jq"
)

func Search(c Criteria) ([]*Record, error) {
	var records []*Record
	var err error

	// first get first page to read how many pages are there to fetch
	firstPage, err := request(c, 0)
	if err != nil {
		return nil, errors.Wrap(err, "request")
	}
	rs, cp, totalPages, err := parseRespPage(firstPage)
	log.Printf("current page: %d total pages %d", cp, totalPages)
	if err != nil {
		log.Printf("error fetching page %v", err)
	}
	records = append(records, rs...)

	n := 1
	// for n <= totalPages {
	for n <= 2 {
		page, err := request(c, n)
		if err != nil {
			return nil, errors.Wrap(err, "request")
		}
		rs, cp, totalPages, err := parseRespPage(page)
		log.Printf("current page: %d total pages %d", cp, totalPages)
		if err != nil {
			log.Printf("error fetching page %d:  %v", n, err)
		}
		records = append(records, rs...)
		n += 1
	}

	return records, err
}

type Criteria struct {
	Longitude    float64 // longitude=-122.07237049999999
	Latitude     float64 // latitude=37.4092297
	ArrivalDate  string  // arrivalDate=2020-08-11
	LengthOfStay int     // lengthOfStay=2
	Interest     string  // interest=camping&
	RCS          int     // rcs=50

}

var baseSearchURL = "https://www.reserveamerica.com/explore/search-results"

func request(c Criteria, pageNum int) (*http.Response, error) {
	c.RCS = 50
	c.Interest = "camping"
	// curl 'https://www.reserveamerica.com/explore/search-results?pageNumber=0&type=nearby&longitude=-122.07237049999999&latitude=37.4092297&
	v := url.Values{
		"pageNumber":   {fmt.Sprint(pageNum)},
		"type":         {"nearby"},
		"longitude":    {fmt.Sprintf("%3.7f", c.Longitude)},
		"latitude":     {fmt.Sprintf("%3.14f", c.Latitude)},
		"arrivalDate":  {c.ArrivalDate},
		"lengthOfStay": {fmt.Sprint(c.LengthOfStay)},
		"interest":     {"camping"},
	}
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	reqStr := fmt.Sprintf("%s?%s", baseSearchURL, v.Encode())
	req, err := http.NewRequest("GET", reqStr, nil)
	if err != nil {
		return nil, errors.Wrap(err, "NewReq")
	}
	req.Header.Set("Connection", "keep-alive")
	req.Header.Set("Upgrade-Insecure-Requests", "1")
	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36")
	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9")
	req.Header.Set("Sec-Fetch-Site", "none")
	req.Header.Set("Sec-Fetch-Mode", "navigate")
	req.Header.Set("Sec-Fetch-Dest", "document")
	req.Header.Set("Accept-Language", "en-US,en;q=0.9")
	return cachedDo(req)

}

func cachedDo(req *http.Request) (*http.Response, error) {
	return http.DefaultClient.Do(req)
}

// returns records, current page, total pages and error
func parseRespPage(resp *http.Response) (records []*Record, currentPage int, totalPages int, err error) {
	doc, err := goquery.NewDocumentFromReader(io.Reader(resp.Body))
	if err != nil {
		return nil, -1, -1, errors.Wrap(err, "goqueryNew")
	}

	raw := ""
	doc.Find("#initialState").Each(func(i int, s *goquery.Selection) {
		raw = s.Text()
	})
	defer resp.Body.Close()

	currentPage, err = jqCurrentPage(raw)
	if err != nil {
		return nil, currentPage, -1, err
	}

	totalPages, err = jqTotalPages(raw)
	if err != nil {
		return nil, currentPage, totalPages, err
	}

	// filter out the relevent json part because golang can't if it in struct
	jqResp, err := filterJq(raw, ".backend.search.searchResults.records")
	if err != nil {
		return nil, -1, -1, errors.Wrap(err, "parseJQ")
	}
	if err := json.Unmarshal(jqResp, &records); err != nil {
		return records, currentPage, totalPages, errors.Wrapf(err, "unmarshalRecords")
	}
	log.Printf("Current Page is %d, Total Pages is %d", currentPage, totalPages)
	return records, currentPage, totalPages, nil
}

func jqCurrentPage(raw string) (int, error) {
	jqResp, err := filterJq(raw, ".backend.search.searchResults.control.currentPage")
	if err != nil {
		return -1, errors.Wrap(err, "jqCurrentPage")
	}

	currentPage, err := strconv.Atoi(string(jqResp))
	if err != nil {
		return -1, errors.Wrap(err, "convertPageToNum")
	}
	return currentPage, nil
}

func jqTotalPages(raw string) (int, error) {
	jqResp, err := filterJq(raw, ".backend.search.searchResults.totalPages")
	if err != nil {
		return -1, errors.Wrap(err, "jqTotalPages")
	}

	totalPages, err := strconv.Atoi(string(jqResp))
	if err != nil {
		return -1, errors.Wrap(err, "convertTotalPagesToNum")
	}
	return totalPages, nil
}

// return smaller part of the json
// because of https://github.com/99designs/gqlgen/issues/810#issuecomment-518965300
func filterJq(input string, filter string) ([]byte, error) {
	var resp []byte
	op, err := jq.Parse(filter) // create an Op
	if err != nil {
		return resp, errors.Wrap(err, "jq parse")
	}
	resp, err = op.Apply([]byte(input)) // value == '"world"'
	log.Printf("length of parsed jq %d", len(resp))
	return resp, err
}

// .backend.search.searchResults.control.currentPage'
// jq '.backend.search.searchResults.totalPages'
